// build.rs - Generates ItemId enum from RON files
//
// Scans assets/items/**/*.item.ron and extracts "id" field from each file.
// Generates src/items/generated.rs with ItemId enum.

use std::collections::HashSet;
use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=assets/items");

    let items_dir = Path::new("assets/items");
    let mut items: Vec<(String, String)> = Vec::new(); // (id, path for error messages)
    let mut seen_ids: HashSet<String> = HashSet::new();

    if items_dir.exists() {
        scan_items(items_dir, &mut items, &mut seen_ids);
    } else {
        eprintln!("Warning: assets/items directory not found");
    }

    // Sort for deterministic output
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let code = generate_enum(&items);

    let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR not set");
    let out_path = Path::new(&out_dir).join("item_ids.rs");
    fs::write(&out_path, code).expect("Failed to write generated code");

    println!("cargo:warning=Generated {} item IDs", items.len());
}

fn scan_items(dir: &Path, items: &mut Vec<(String, String)>, seen_ids: &mut HashSet<String>) {
    let entries = match fs::read_dir(dir) {
        Ok(e) => e,
        Err(e) => {
            eprintln!("Warning: Cannot read {:?}: {}", dir, e);
            return;
        }
    };

    for entry in entries.flatten() {
        let path = entry.path();

        if path.is_dir() {
            scan_items(&path, items, seen_ids);
        } else if path.extension().map(|e| e == "ron").unwrap_or(false) {
            if let Some(id) = extract_id(&path) {
                // Check for duplicates
                if seen_ids.contains(&id) {
                    panic!(
                        "Duplicate item ID '{}' found in {:?}. Each item must have a unique ID.",
                        id, path
                    );
                }
                seen_ids.insert(id.clone());
                items.push((id, path.display().to_string()));
            }
        }
    }
}

fn extract_id(path: &Path) -> Option<String> {
    let content = fs::read_to_string(path).ok()?;

    // Simple parser: find id: "..." pattern
    // Handles both `id: "something"` and `id: "something",`
    for line in content.lines() {
        let line = line.trim();
        if line.starts_with("id:") {
            // Extract the string value
            if let Some(start) = line.find('"') {
                if let Some(end) = line[start + 1..].find('"') {
                    let id = &line[start + 1..start + 1 + end];
                    return Some(id.to_string());
                }
            }
        }
    }

    eprintln!("Warning: No 'id' field found in {:?}", path);
    None
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

fn generate_enum(items: &[(String, String)]) -> String {
    let mut code = String::new();

    // Header
    code.push_str("// GENERATED BY build.rs â€” DO NOT EDIT\n");
    code.push_str("// Re-run `cargo build` after adding/modifying items in assets/items/\n\n");

    // Imports
    code.push_str("use serde::{Deserialize, Serialize};\n\n");

    // Enum definition
    code.push_str("#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Serialize, Deserialize)]\n");
    code.push_str("#[repr(u32)]\n");
    code.push_str("pub enum ItemId {\n");

    for (i, (id, _path)) in items.iter().enumerate() {
        let variant = to_pascal_case(id);
        code.push_str(&format!("    {} = {},\n", variant, i));
    }

    code.push_str("}\n\n");

    // Impl block
    code.push_str("impl ItemId {\n");

    // as_str method
    code.push_str("    /// Get the string ID (matches RON file)\n");
    code.push_str("    pub const fn as_str(&self) -> &'static str {\n");
    code.push_str("        match self {\n");
    for (id, _) in items {
        let variant = to_pascal_case(id);
        code.push_str(&format!("            Self::{} => \"{}\",\n", variant, id));
    }
    code.push_str("        }\n");
    code.push_str("    }\n\n");

    // from_str method
    code.push_str("    /// Parse from string ID\n");
    code.push_str("    pub fn from_str(s: &str) -> Option<Self> {\n");
    code.push_str("        match s {\n");
    for (id, _) in items {
        let variant = to_pascal_case(id);
        code.push_str(&format!("            \"{}\" => Some(Self::{}),\n", id, variant));
    }
    code.push_str("            _ => None,\n");
    code.push_str("        }\n");
    code.push_str("    }\n\n");

    // all method
    code.push_str("    /// Iterator over all item IDs\n");
    code.push_str("    pub fn all() -> impl Iterator<Item = Self> {\n");
    code.push_str("        [\n");
    for (id, _) in items {
        let variant = to_pascal_case(id);
        code.push_str(&format!("            Self::{},\n", variant));
    }
    code.push_str("        ].into_iter()\n");
    code.push_str("    }\n\n");

    // count method
    code.push_str("    /// Total number of items\n");
    code.push_str(&format!(
        "    pub const fn count() -> usize {{ {} }}\n",
        items.len()
    ));

    code.push_str("}\n\n");

    // Display impl
    code.push_str("impl std::fmt::Display for ItemId {\n");
    code.push_str("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n");
    code.push_str("        write!(f, \"{}\", self.as_str())\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    code
}
